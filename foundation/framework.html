<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>框架 | 青年家威</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="logo.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.01c1b0ce.css" as="style"><link rel="preload" href="/assets/js/app.81356f24.js" as="script"><link rel="preload" href="/assets/js/2.2bdd9eae.js" as="script"><link rel="preload" href="/assets/js/3.4918c403.js" as="script"><link rel="prefetch" href="/assets/js/10.1c6e92fe.js"><link rel="prefetch" href="/assets/js/11.42dbd017.js"><link rel="prefetch" href="/assets/js/12.b4c17f9b.js"><link rel="prefetch" href="/assets/js/13.dcf0a415.js"><link rel="prefetch" href="/assets/js/14.c88356c6.js"><link rel="prefetch" href="/assets/js/15.3b6109c6.js"><link rel="prefetch" href="/assets/js/16.e370d905.js"><link rel="prefetch" href="/assets/js/17.a321d5ca.js"><link rel="prefetch" href="/assets/js/18.3730016e.js"><link rel="prefetch" href="/assets/js/19.51f3d312.js"><link rel="prefetch" href="/assets/js/20.30152331.js"><link rel="prefetch" href="/assets/js/21.3a6ef589.js"><link rel="prefetch" href="/assets/js/22.d0ddbaba.js"><link rel="prefetch" href="/assets/js/23.d530963c.js"><link rel="prefetch" href="/assets/js/4.b04740a9.js"><link rel="prefetch" href="/assets/js/5.bd727705.js"><link rel="prefetch" href="/assets/js/6.a748600d.js"><link rel="prefetch" href="/assets/js/7.2d2d56a7.js"><link rel="prefetch" href="/assets/js/8.090fc473.js"><link rel="prefetch" href="/assets/js/9.adf75988.js">
    <link rel="stylesheet" href="/assets/css/0.styles.01c1b0ce.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">青年家威</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/aboutme/" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="/archite/" class="nav-link">
  架构之路
</a></div><div class="nav-item"><a href="/foundation/" class="nav-link router-link-active">
  技术积累
</a></div><div class="nav-item"><a href="https://juejin.im/user/4300945220716103/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://blog.csdn.net/liujiawei00" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/aboutme/" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="/archite/" class="nav-link">
  架构之路
</a></div><div class="nav-item"><a href="/foundation/" class="nav-link router-link-active">
  技术积累
</a></div><div class="nav-item"><a href="https://juejin.im/user/4300945220716103/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://blog.csdn.net/liujiawei00" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/foundation/" aria-current="page" class="sidebar-link">技术积累</a></li><li><a href="/foundation/js.html" class="sidebar-link">Javascript</a></li><li><a href="/foundation/framework.html" aria-current="page" class="active sidebar-link">框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/foundation/framework.html#vue中plugin和mixins的区别" class="sidebar-link">Vue中plugin和mixins的区别</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#vue中-nexttick和settimeout的区别" class="sidebar-link">Vue中$nextTick和setTimeout的区别</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#watch和computed的区别" class="sidebar-link">watch和computed的区别</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#ocr识别开源库-tesseract-js" class="sidebar-link">OCR识别开源库：tesseract.js</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#vue里的组件属性attrs" class="sidebar-link">Vue里的组件属性attrs</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#vue为什么要异步更新队列" class="sidebar-link">Vue为什么要异步更新队列？</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#vue的模版编译" class="sidebar-link">Vue的模版编译</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#vue的virtualdom" class="sidebar-link">Vue的VirtualDOM</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#vue的变化侦测" class="sidebar-link">Vue的变化侦测</a></li><li class="sidebar-sub-header"><a href="/foundation/framework.html#vue中的生命周期" class="sidebar-link">Vue中的生命周期</a></li></ul></li><li><a href="/foundation/css.html" class="sidebar-link">CSS</a></li><li><a href="/foundation/typescript.html" class="sidebar-link">Typescript</a></li><li><a href="/foundation/algorithm.html" class="sidebar-link">算法与数据结构</a></li><li><a href="/foundation/http.html" class="sidebar-link">Http与计算机网络</a></li><li><a href="/foundation/html.html" class="sidebar-link">Html</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="框架"><a href="#框架" class="header-anchor">#</a> 框架</h1> <h2 id="vue中plugin和mixins的区别"><a href="#vue中plugin和mixins的区别" class="header-anchor">#</a> Vue中<code>plugin</code>和<code>mixins</code>的区别</h2> <p>区别在于，对于需要该功能的每个组件，必须在vm定义的mixin hash中引入这个mixin。plugin使它在所有组件中全局可用，而无需引入（因为它扩展了主Vue实例，因此您创建的每个组件都已包含此功能）</p> <p>Mixins通常会单独添加到组件中，除非大多数组件都需要该功能。</p> <p>当然了，我们也可以创建全局Mixin，但是从Vue的官方文档中，是不建议这么做的。官方文档是这么说的：</p> <p>谨慎使用全局mixins，因为它会影响创建的每个Vue实例，包括第三方组件。 在大多数情况下，仅应将其用于自定义选项处理(custom option handling )，如下例所示。 推荐将其作为<strong>插件</strong>发布，以避免重复应用混入。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// inject a handler for `myOption` custom option</span>
Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> myOption <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>myOption
        <span class="token keyword">if</span> <span class="token punctuation">(</span>myOption<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myOption<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    myOption<span class="token operator">:</span> <span class="token string">'hello!'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// =&gt; &quot;hello!&quot;</span>
</code></pre></div><p>因此，在一般情况下，对于需要全局使用的方法/处理函数，我们还是使用Plugin的方式。</p> <p>Plugin暴露一个install接口，里面包含一些选项，然后使用Vue.use()即可。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> plugin <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">install</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$helpers <span class="token operator">=</span> helpers<span class="token punctuation">;</span> <span class="token comment">//helpers可能是你自己的全局方法JS文件</span>
        <span class="token comment">// 2. add a global asset</span>
        Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
            <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// some logic ...</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>

        <span class="token comment">// 3. inject some component options</span>
        Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// some logic ...</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>plugin<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>另外，其实我们应该谨慎考虑使用<code>mixins</code>:</p> <ol><li>Mixin 引入了隐式依赖关系。JavaScript是一种动态语言，所以很难执行或记录这些依赖关系。与组件不同，mixin不构成层次结构：它们被夷为平地并在相同的名称空间中运行。</li> <li>Mixins导致名称冲突。因为一个名称相同的方法可能已经存在于一些使用它的组件。mixin很难删除或更改。不好的想法不会被重构，因为重构风险太大。</li> <li>Mixin导致复杂的滚雪球。逐渐地，封装边界逐渐消失，由于很难改变或移除现有的混合，他们不断变得抽象，直到没人理解它们是如何工作的。</li></ol> <h2 id="vue中-nexttick和settimeout的区别"><a href="#vue中-nexttick和settimeout的区别" class="header-anchor">#</a> Vue中<code>$nextTick</code>和<code>setTimeout</code>的区别</h2> <p>nextTick 源码在 src/core/util/next-tick.js 里面。</p> <p>在vue的next-tick实现中使用了几种情况来延迟调用该函数，首先我们会判断我们的设备是否支持Promise对象，如果支持的话，会使用 Promise.then 来做延迟调用函数。如果设备不支持Promise对象，再判断是否支持 MutationObserver 对象，如果支持就使用MutationObserver来做延迟，如果不支持的话，我们会使用setImmediate，如果不支持setImmediate的话， 会使用setTimeout 来做延迟操作。</p> <p>所以，setImmediate和setTimeout这两种宏任务可以看作是降级处理，一般情况都不会用到。</p> <h4 id="js中的event-loop"><a href="#js中的event-loop" class="header-anchor">#</a> JS中的Event Loop</h4> <p>我们都明白，javascript是单线程的，所有的任务都会在主线程中执行的，当主线程中的任务都执行完成之后，系统会 &quot;依次&quot; 读取任务队列里面的事件，因此对应的异步任务进入主线程，开始执行。</p> <p>但是异步任务队列又分为: macrotasks(宏任务) 和 microtasks(微任务)。 他们两者分别有如下API:</p> <ul><li>macrotasks(宏任务): setTimeout、setInterval、setImmediate、I/O、UI rendering 等。</li> <li>microtasks(微任务): Promise、process.nextTick、MutationObserver 等。</li></ul> <p>promise的then方法的函数会被推入到 microtasks(微任务) 队列中(Promise本身代码是同步执行的)，而setTimeout函数会被推入到 macrotasks(宏任务) 任务队列中，在每一次事件循环中 macrotasks(宏任务) 只会提取一个执行，而 microtasks(微任务) 会一直提取，直到 microtasks(微任务)队列为空为止。</p> <p>也就是说，如果某个 microtasks(微任务) 被推入到执行中，那么当主线程任务执行完成后，会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为止。而事件循环每次只会入栈一个 macrotasks(宏任务), 主线程执行完成该任务后又会循环检查 microtasks(微任务) 队列是否还有未执行的，直到所有的执行完成后，再执行 macrotasks(宏任务)。 依次循环，直到所有的异步任务完成为止。</p> <p>现在我们来看一个简单的例子分析一下：</p> <div class="language-js extra-class"><pre class="language-js"><code>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            i <span class="token operator">===</span> <span class="token number">99</span> <span class="token operator">&amp;&amp;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打印结果：</p> <div class="language- extra-class"><pre class="language-text"><code>
1
3
4
6
5
2
</code></pre></div><p>再试试这个复杂点的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          i <span class="token operator">===</span> <span class="token number">9999</span> <span class="token operator">&amp;&amp;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打印结果：</p> <div class="language- extra-class"><pre class="language-text"><code>
1
3
4
8
6
5
9
7
2
</code></pre></div><p>值得一提的是，微任务执行完成后，就执行第二个宏任务setTimeout，由于第一个setTimeout是10毫秒后执行，第二个setTimeout是1毫秒后执行，因此1毫秒的优先级大于10毫秒的优先级，因此最后分别打印 7, 2 了</p> <p>而很多人会发现<strong>vue中的nextTick会比setTimeout优先级高</strong>，就是因为nextTick是以微任务Promise.then优先的。</p> <p><strong>Vue的特点之一就是能实现响应式，但数据更新时，DOM不会立即更新，而是放入一个异步队列中，因此如果在我们的业务场景中，有一段代码里面的逻辑需要在DOM更新之后才能顺利执行，这个时候我们可以使用this.$nextTick() 函数来实现。</strong></p> <p>分析nextTick的源码(Vue2.6.10)：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/* @flow */</span>
<span class="token comment">/* globals MutationObserver */</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span>
    noop
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'shared/util'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
    handleError
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./error'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
    isIE<span class="token punctuation">,</span>
    isIOS<span class="token punctuation">,</span>
    isNative
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./env'</span>

<span class="token keyword">export</span> <span class="token keyword">let</span> isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">const</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">//用来存储所有需要执行的回调函数</span>
<span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">//该变量的作用是表示状态，判断是否有正在执行的回调函数。</span>

<span class="token keyword">function</span> <span class="token function">flushCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pending <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">const</span> copies <span class="token operator">=</span> callbacks<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    callbacks<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> copies<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        copies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> timerFunc

<span class="token comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span>
<span class="token comment">// via either native Promise.then or MutationObserver.</span>
<span class="token comment">// MutationObserver has wider support, however it is seriously bugged in</span>
<span class="token comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span>
<span class="token comment">// completely stops working after triggering a few times... so, if native</span>
<span class="token comment">// Promise is available, we will use it:</span>
<span class="token comment">/* istanbul ignore next, $flow-disable-line */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>Promise<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
        <span class="token comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span>
        <span class="token comment">// it can get stuck in a weird state where callbacks are pushed into the</span>
        <span class="token comment">// microtask queue but the queue isn't being flushed, until the browser</span>
        <span class="token comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>
        <span class="token comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isIOS<span class="token punctuation">)</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>noop<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isIE <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> MutationObserver <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
        <span class="token function">isNative</span><span class="token punctuation">(</span>MutationObserver<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token comment">// PhantomJS and iOS 7.x</span>
        MutationObserver<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object MutationObserverConstructor]'</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Use MutationObserver where native Promise is not available,</span>
    <span class="token comment">// e.g. PhantomJS, iOS7, Android 4.4</span>
    <span class="token comment">// (#6466 MutationObserver is unreliable in IE11)</span>

    <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
    <span class="token keyword">const</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span>
    observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        characterData<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span>
        textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// timerFunc函数执行时会导致文本节点textNode的数据发生改变，因为MutationObserver对象在监听文本节点，</span>
    <span class="token comment">//所以进而也就会触发flushCallbacks回调函数</span>
    isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Fallback to setImmediate.</span>
    <span class="token comment">// Techinically it leverages the (macro) task queue,</span>
    <span class="token comment">// but it is still a better choice than setTimeout.</span>
    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Fallback to setTimeout.</span>
    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token parameter">cb <span class="token operator">?</span> <span class="token operator">:</span> Function<span class="token punctuation">,</span> ctx <span class="token operator">?</span> <span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _resolve
    callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> <span class="token string">'nextTick'</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">_resolve</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pending <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token function">timerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//如果cb不是一个函数的话, 那么会判断是否有_resolve值, 有该值就使用Promise.then() 这样的方式来调用。比如: this.$nextTick().then(cb) 这样的使用方式。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cb <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            _resolve <span class="token operator">=</span> resolve
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="mutationobserver"><a href="#mutationobserver" class="header-anchor">#</a> MutationObserver</h4> <p>MutationObserver是监听DOM变动的接口，DOM发生任何变动，MutationObserver会得到通知。在Vue中是通过该属性来监听DOM更新完毕的。</p> <p>它和事件类似，但有所不同，事件是同步的，当DOM发生变动时，事件会立刻处理，但是 MutationObserver 则是异步的，它不会立即处理，而是等页面上所有的DOM完成后，会执行一次，如果页面上要操作100次DOM的话，如果是事件的话会监听100次DOM，但是我们的 MutationObserver 只会执行一次，它是等待所有的DOM操作完成后，再执行。</p> <p>MutationObserver 构造函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>观察器callback回调函数会在每次DOM发生变动后调用，它接收2个参数，第一个是变动的数组，第二个是观察器的实列。</p> <p>MutationObserver实例的方法</p> <p>observe() ：该方法是要观察DOM节点的变动的。该方法接收2个参数，第一个参数是要观察的DOM元素，第二个是要观察的变动类型。</p> <div class="language-js extra-class"><pre class="language-js"><code>observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>dom<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>options 类型有如下：</p> <ul><li>childList: 子节点的变动。</li> <li>attributes: 属性的变动。</li> <li>characterData: 节点内容或节点文本的变动。</li> <li>subtree: 所有后代节点的变动。</li></ul> <p>需要观察哪一种变动类型，需要在options对象中指定为true即可；但是如果设置subtree的变动，必须同时指定childList, attributes, 和 characterData 中的一种或多种。</p> <h2 id="watch和computed的区别"><a href="#watch和computed的区别" class="header-anchor">#</a> <code>watch</code>和<code>computed</code>的区别</h2> <h3 id="watch的使用场景"><a href="#watch的使用场景" class="header-anchor">#</a> watch的使用场景</h3> <p>当在data中的某个数据发生变化时, 我们需要做一些操作, 或者当需要在数据变化时执行异步或开销较大的操作时, 我们就可以使用watch来进行监听。</p> <p>对于dialog需要每次打开都执行一段逻辑的情景，目前暂时使用watch，等我再研究研究看有没有替代方案。</p> <ul><li>谨慎使用deep为true，性能开销会非常大。</li> <li>immediate:true的话, 第一次页面加载的时候也会执行watch的handler函数。</li></ul> <h3 id="computed的使用场景"><a href="#computed的使用场景" class="header-anchor">#</a> computed的使用场景</h3> <ol><li>使模板中的逻辑更清晰, 方便代码管理。</li> <li>计算之后的值会被缓存起来, 依赖的data值改变后会重新计算。</li></ol> <h3 id="computed-为什么要缓存"><a href="#computed-为什么要缓存" class="header-anchor">#</a> computed 为什么要缓存</h3> <p>优化性能，避免造成性能浪费，提升体验</p> <h3 id="computed和methods的区别"><a href="#computed和methods的区别" class="header-anchor">#</a> computed和methods的区别</h3> <div class="language-js extra-class"><pre class="language-js"><code> computed<span class="token operator">:</span> <span class="token punctuation">{</span>
     <span class="token function">reversedMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// this 指向 vm 实例</span>
         <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre></div><ol><li>computed 是基于响应性依赖来进行缓存的。只有在响应式依赖发生改变时它们才会重新求值, 以上面的代码为例, 当msg属性值没有发生改变时, <strong>多次访问 reversedMsg 计算属性会立即返回之前缓存的计算结果</strong>, 而不会再次执行computed中的函数。但是methods方法中是<strong>每次调用, 都会执行函数</strong>的, methods它不是响应式的。</li> <li>computed中的成员可以只定义一个函数作为只读属性, 也可以定义成 get/set变成可读写属性, 但是methods中的成员没有这样的。</li></ol> <h3 id="coumuted和watch的区别"><a href="#coumuted和watch的区别" class="header-anchor">#</a> coumuted和watch的区别</h3> <p>相同点：他们两者都是观察页面数据变化的。</p> <p>不同点：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。
watch每次都需要执行函数。watch更适用于数据变化时的异步操作。</p> <h2 id="ocr识别开源库-tesseract-js"><a href="#ocr识别开源库-tesseract-js" class="header-anchor">#</a> OCR识别开源库：tesseract.js</h2> <p>GitHub地址：https://github.com/naptha/tesseract.js#tesseractjs</p> <h2 id="vue里的组件属性attrs"><a href="#vue里的组件属性attrs" class="header-anchor">#</a> Vue里的组件属性<code>attrs</code></h2> <ul><li>$attrs和$listeners</li></ul> <p>比如一个父组件：</p> <div class="language-html extra-class"><pre class="language-html"><code>template:

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> attrs: {{$attrs}} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> foo: {{foo}} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

js:
props: {
foo: {
type: String,
default: ''
}
}
</code></pre></div><p>然后在祖先组件里面使用：</p> <div class="language-html extra-class"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>father-component</span> <span class="token attr-name">:foo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:bar</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bar<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>reciveChildFunc()<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>father-component</span><span class="token punctuation">&gt;</span></span>

     ...

     data() {
     return {
     foo: 'hello world',
     bar: 'kongzhi'
     }
     },
</code></pre></div><p>注意，我们在父组件里传了俩属性，但是自组件只接收一个 <code>foo</code> ，那么另外一个会发生什么呢？</p> <p>Vue里2.4+版本之后，新增加 <code>$attrs</code> 来接收祖先组件传递给父组件中但是未在props对象里面声明的数据。</p> <p>所以上面的代码$attrs就是:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    bar<span class="token operator">:</span> <span class="token string">'kongzhi'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>爷组件和孙组件通信，中间的父组件如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-component</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$attrs<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$listeners<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child-component</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li>inheritAttrs，默认为true</li></ul> <p>而且bar参数默认会把属性放入到我们父组件的根元素上当做一个普通属性：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">bar</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>kongzhi<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>如果我们不想让未使用的属性放入到父组件的根元素上当做普通属性的话, 我们可以在父组件上把 inheritAttrs 设置为false即可。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 这是新增的代码</span>
  inheritAttrs<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>

      props<span class="token operator">:</span> <span class="token punctuation">{</span>
          foo<span class="token operator">:</span> <span class="token punctuation">{</span>
              type<span class="token operator">:</span> String<span class="token punctuation">,</span>
              <span class="token keyword">default</span><span class="token operator">:</span> <span class="token string">''</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h2 id="vue为什么要异步更新队列"><a href="#vue为什么要异步更新队列" class="header-anchor">#</a> Vue为什么要异步更新队列？</h2> <p>异步更新队列指的是当状态发生变化时，Vue异步执行DOM更新。</p> <p>组件内部使用Virtualdom进行渲染，也就是说，组件内部其实是不关心哪个状态发生了变化，它只需要计算一次就可以得知哪些节点需要更新。也就是说，如果更改了N个状态，其实只需要发送一个信号就可以将DOM更新到最新。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'更新完成'</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span>  <span class="token number">23</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> berwin
</code></pre></div><p>代码中我们分三次修改了三种状态，但其实Vue只会渲染一次。因为<code>Virtualdom</code>只需要一次就可以将整个组件的DOM更新到最新，它根本不会关心这个更新的信号到底是从哪个具体的状态发出来的。</p> <p>那如何才能将渲染操作推迟到所有状态都修改完毕呢？很简单，只需要将渲染操作推迟到本轮事件循环的最后或者下一轮事件循环。也就是说，只需要在本轮事件循环的最后，等前面更新状态的语句都执行完之后，执行一次渲染操作。这样无论前面写了多少条更新状态的语句，只在最后渲染一次就可以了。</p> <p>将渲染推迟到本轮事件循环的最后执行渲染的时机会比推迟到下一轮快很多，所以Vue优先将渲染操作推迟到本轮事件循环的最后(<code>微任务</code>)，如果执行环境不支持会降级到下一轮（<code>宏任务</code>）。</p> <p>当然，Vue的变化侦测机制决定了它必然会在每次状态发生变化时都会发出渲染的信号，但Vue会在收到信号之后检查队列中是否已经存在这个任务。如果队列中不存在则将渲染操作添加到队列中，这样可以保证队列中不会有重复。</p> <p>之后通过异步的方式延迟执行队列中的所有渲染的操作（<code>微任务</code>）并清空队列。当同一轮事件循环中反复修改状态时，并不会反复向队列中添加相同的渲染操作。</p> <p>所以我们在使用Vue时，修改状态后更新DOM都是异步的。</p> <p>问题1:</p> <p>解释下面代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token function-variable function">example</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 先使用nextTick注册回调</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// DOM没有更新</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token comment">// 后修改数据</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'changed'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>因为Vue更新dom是异步的，而且是优先加入微任务队列的，所以这里nextTick获取dom因为也是微任务队列，而且位于修改状态的语句之前，所以nextTick的执行顺序是在状态修改之前的。故而此时dom还未更新。</p> <p>所以使用nextTick获取dom的代码都应该在更新状态的代码之后。</p> <p>问题2:</p> <p>解释下面代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token function-variable function">example</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 先使用setTimeout向宏任务中注册回调</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token parameter">_</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// DOM现在更新了</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token comment">// 后修改数据向微任务中注册回调</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'changed'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p>因为setTimeout是宏任务，他的执行顺序在微任务之后，所以他的代码顺序是无所谓的。即使状态修改的代码位于setTimeout回调的后面，他也会先于setTimeout执行。</p> <h2 id="vue的模版编译"><a href="#vue的模版编译" class="header-anchor">#</a> Vue的模版编译</h2> <p>参考资料：</p> <p><a href="https://github.com/berwin/Blog/issues/18" target="_blank" rel="noopener noreferrer">博客文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Vue中的模板非常重要，我们可以在模板里面访问变量。</p> <p>在vue中创建HTML并不只模板这一种办法，我们既可以手写渲染函数来创建HTML，也可以在使用JSX来创建HTML。</p> <p>模板如何编译为渲染函数呢？</p> <h3 id="解析器"><a href="#解析器" class="header-anchor">#</a> 解析器</h3> <p>其实这样一个模板解析器的原理不是特别难，主要就是两部分内容，一部分是 <code>截取</code> 字符串，一部分是对截取之后的字符串做 <code>解析</code></p> <p>每截取一段标签的开头就 <code>push</code> 到 <code>stack</code>中，解析到标签的结束就 <code>pop</code> 出来，当所有的字符串都截没了也就解析完了。</p> <p>最后将模板解析成AST（抽象语法树）。</p> <h3 id="优化器"><a href="#优化器" class="header-anchor">#</a> 优化器</h3> <p>整体逻辑其实就是遍历 <code>AST</code> 这颗树，然后使用递归，将 <strong>静态节点</strong> 和 <strong>静态根节点</strong> 找到并打上标记。</p> <h3 id="代码生成器"><a href="#代码生成器" class="header-anchor">#</a> 代码生成器</h3> <p>代码生成器的作用是使用 <code>element ASTs</code> 生成 <code>render</code> 函数代码字符串。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>解析器（parser）的原理是一小段一小段的去截取字符串，然后维护一个 <code>stack</code> 用来保存DOM深度，每截取到一段标签的开始就 <code>push</code> 到 <code>stack</code> 中，当所有字符串都截取完之后也就解析出了一个完整的 <code>AST</code>。</p> <p>优化器（optimizer）的原理是用递归的方式将所有节点打标记，表示是否是一个 <code>静态节点</code>，然后再次递归一遍把 <code>静态根节点</code> 也标记出来。</p> <p>代码生成器（code generator）的原理也是通过递归去拼一个函数执行代码的字符串，递归的过程根据不同的节点类型调用不同的生成方法，如果发现是一颗元素节点就拼一个 <code>_c(tagName, data, children)</code> 的函数调用字符串，然后 <code>data</code> 和 <code>children</code> 也是使用 <code>AST</code> 中的属性去拼字符串；文本节点拼一个_v( )，注释节点拼一个 _e( )。</p> <p>如果 <code>children</code> 中还有 <code>children</code> 则递归去拼。</p> <p>最后拼出一个完整的渲染函数代码。</p> <p>这个渲染函数执行之后，会得到一份vnode用于虚拟dom渲染。</p> <h2 id="vue的virtualdom"><a href="#vue的virtualdom" class="header-anchor">#</a> Vue的VirtualDOM</h2> <p>参考资料：</p> <p><a href="https://ppt.baomitu.com/d/2afbd5b9#/" target="_blank" rel="noopener noreferrer"> 最好的、最容易理解的讲VirtualDOM的PPT<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟DOM</h3> <p>虚拟DOM是将状态映射为视图的众多解决办法中的一个（Angular的脏检查、Vue中的变化侦测细粒度绑定）。</p> <p>Vue.js中通过模板来描述状态和视图之间的映射关系，所以它会先将模板编译为渲染函数，然后执行渲染函数生成虚拟节点vnode，最后使用虚拟节点更新视图。</p> <p>因此，虚拟DOM在vue中做的就是提供虚拟节点vnode以及通过对比新旧vnode来找出需要更新的部分来提升性能。根据比对结果进行DOM操作来更新视图。</p> <h3 id="vnode"><a href="#vnode" class="header-anchor">#</a> Vnode</h3> <ul><li>注释节点（isComment为true）</li> <li>文本节点（只有text属性）</li> <li>元素节点（tag, data,children,context）</li> <li>组件节点（componentOptions，componentInstance）</li> <li>函数式组件（functionalOptions，functionalContext）</li> <li>克隆节点（isCloned为true）</li></ul> <p>VNode是一个类，可以生成类型不同的实例，这些vnode实例代表不同的真实dom元素。</p> <p>由于Vue对组件使用了虚拟DOM来更新视图，当组件里的状态发生变化时，整个组件都要重新渲染，但是并不是所有的DOM都需要更新，所以将vnode缓存并在新的vnode生成之后通过和旧的vnode对比，就可以找到需要更新的vnode，也就可以只对需要更新的部分进行DOM操作来提升性能。</p> <h3 id="patch"><a href="#patch" class="header-anchor">#</a> Patch</h3> <p>虚拟DOM最核心的部分是Patch，它可以将Vnode渲染成真实的DOM 。</p> <p>patch也可以叫做Patching算法，通过它渲染真实DOM时，并不是暴力的覆盖原DOM，而是通过新旧 vnode对比找出哪些需要更新的节点。patch名字本身就有补丁、修补等意思，其实际作用是在现有DOM上更改来实现试图更新。</p> <p>之所以这么做，是因为DOM操作的速度远不如JS的运算速度。因此，把大量的DOM操作搬运到JS中，使用patch算法找出需要更新的节点，最大限度的减少DOM的操作，从而提升性能。</p> <h3 id="创建节点"><a href="#创建节点" class="header-anchor">#</a> 创建节点</h3> <p><img src="/assets/img/createNode.3f2bea85.png" alt="Image"></p> <h3 id="更新节点"><a href="#更新节点" class="header-anchor">#</a> 更新节点</h3> <p><img src="/assets/img/updateNode.c740cc3e.png" alt="Image"></p> <h3 id="子节点的对比"><a href="#子节点的对比" class="header-anchor">#</a> 子节点的对比</h3> <p>新增、移动、更新、删除</p> <h2 id="vue的变化侦测"><a href="#vue的变化侦测" class="header-anchor">#</a> Vue的变化侦测</h2> <p>参考资料：</p> <ul><li><a href="https://github.com/berwin/Blog/issues/17" target="_blank" rel="noopener noreferrer">博客文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.ituring.com.cn/book/tupubarticle/29448" target="_blank" rel="noopener noreferrer">深入浅出Vue.js对象的变化侦测章节<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="什么是变化侦测"><a href="#什么是变化侦测" class="header-anchor">#</a> 什么是变化侦测</h3> <p>Vue.js会自动通过状态生成DOM，并将其输出到页面上显示出来，这个过程叫渲染。Vue.js的渲染过程是声明式的，我们通过模板来描述状态与DOM之间的映射关系。</p> <p>通常，在运行时应用内部的状态会不断发生变化，此时需要不停地重新渲染。这时如何确定状态中发生了什么变化？</p> <p>变化侦测就是用来解决这个问题的，它分为两种类型：一种是“推”（push），另一种是“拉”（pull）。</p> <p>Angular和React中的变化侦测都属于“拉”，这就是说当状态发生变化时，它不知道哪个状态变了，只知道状态有可能变了，然后会发送一个信号告诉框架，框架内部收到信号后，会进行一个暴力比对来找出哪些DOM节点需要重新渲染。这在Angular中是脏检查的流程，在React中使用的是虚拟DOM。</p> <p>而Vue.js的变化侦测属于“推”。当状态发生变化时，Vue.js立刻就知道了，而且在一定程度上知道哪些状态变了。因此，它知道的信息更多，也就可以进行更细粒度的更新。</p> <p>所谓更细粒度的更新，就是说：假如有一个状态绑定着好多个依赖，每个依赖表示一个具体的DOM节点，那么当这个状态发生变化时，向这个状态的所有依赖发送通知，让它们进行DOM更新操作。相比较而言，“拉”的粒度是最粗的。</p> <p>但是它也有一定的代价，因为粒度越细，每个状态所绑定的依赖就越多，依赖追踪在内存上的开销就会越大。因此，从Vue.js 2.0开始，它引入了虚拟DOM，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是具体的DOM节点，而是一个组件。这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。</p> <p>Vue.js之所以能随意调整粒度，本质上还要归功于变化侦测。因为“推”类型的变化侦测可以随意调整粒度。</p> <h3 id="如何追踪变化"><a href="#如何追踪变化" class="header-anchor">#</a> 如何追踪变化</h3> <p>Object.defineProperty和ES6中的Proxy</p> <h3 id="observer"><a href="#observer" class="header-anchor">#</a> Observer</h3> <p>Observer类会附加到每一个被侦测的object上。一旦被附加上，Observer会将object的所有属性转换为getter/setter的形式。来收集属性的依赖，并且当属性发生变化时会通知这些依赖</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> Dep <span class="token keyword">from</span> <span class="token string">'./Dep'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">walk</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> obj<span class="token punctuation">[</span>keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//收集依赖</span>
            <span class="token keyword">return</span> val
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
            dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//触发依赖</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="dep"><a href="#dep" class="header-anchor">#</a> Dep</h3> <p>它用来收集依赖、删除依赖和向依赖发送消息等。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Watcher <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./Watcher&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span>  <span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">;</span> <span class="token comment">//target: ?Watcher;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">addSub</span><span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">removeSub</span><span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">,</span> sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token keyword">instanceof</span> <span class="token class-name">Watcher</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> subs<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> subs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> index <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="watcher"><a href="#watcher" class="header-anchor">#</a> Watcher</h3> <p><code>Watcher</code>是一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Dep <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./Dep&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> expOrFn<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span><span class="token comment">// vm指当前的Vue实例</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>getter <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>expOrFn<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读取vm.$data中的值，同时会触发属性上的getter</span>
    <span class="token punctuation">}</span>

    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Watcher把自己设置到全局唯一的指定位置，在这里就是Dep.target</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token comment">//读取数据，触发这个数据的getter。因此Observer会收集依赖，将这个Watcher收集到Dep，也就是依赖收集。</span>
        <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//收集结束，清除Dep.target的内容</span>
        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">//返回读取到的数据值</span>
        <span class="token keyword">return</span> value
    <span class="token punctuation">}</span>

    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//数据改变之后，Dep会依次循环向依赖发通知，这里接到通知之后，先获取之前的旧数据</span>
        <span class="token keyword">const</span> oldValue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token comment">//然后获取最新的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将新旧值传给回调函数</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> bailRE <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[^\w.$]</span><span class="token regex-delimiter">/</span></span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parsePath</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bailRE<span class="token punctuation">.</span><span class="token function">tetx</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> segments <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
            obj <span class="token operator">=</span> obj<span class="token punctuation">[</span>segments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="总结综述"><a href="#总结综述" class="header-anchor">#</a> 总结综述</h3> <p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。</p> <p><code>Object</code>可以通过<code>Object.defineProperty</code>将属性转换成getter/setter的形式来追踪变化。读取数据时会触发getter，修改数据时会触发setter。</p> <p>我们需要在getter中收集有哪些依赖使用了数据。当setter被触发时，去通知getter中收集的依赖数据发生了变化。</p> <p>收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了<code>Dep</code>，它用来收集依赖、删除依赖和向依赖发送消息等。</p> <p>所谓的依赖，其实就是<code>Watcher</code>。只有<code>Watcher</code>触发的getter才会收集依赖，哪个<code>Watcher</code>触发了getter，就把哪个<code>Watcher</code>收集到<code>Dep</code>中。当数据发生变化时，会循环依赖列表，把所有的<code>Watcher</code>都通知一遍。</p> <p><code>Watcher</code>的原理是先把自己设置到全局唯一的指定位置（例如<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>Watcher</code>收集到<code>Dep</code>中去。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。</p> <p>此外，我们创建了<code>Observer</code>类，它的作用是把一个<code>object</code>中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测<code>object</code>中所有数据（包括子数据）的变化。</p> <p>由于在ES6之前JavaScript并没有提供元编程的能力，所以在对象上新增属性和删除属性都无法被追踪到。</p> <h3 id="data、observer、dep和watcher之间的关系"><a href="#data、observer、dep和watcher之间的关系" class="header-anchor">#</a> Data、Observer、Dep和Watcher之间的关系</h3> <p><code>Data</code>通过<code>Observer</code>转换成了getter/setter的形式来追踪变化。</p> <p>当外界通过<code>Watcher</code>读取数据时，会触发getter从而将<code>Watcher</code>添加到依赖中。</p> <p>当数据发生了变化时，会触发setter，从而向<code>Dep</code>中的依赖（<code>Watcher</code>）发送通知。</p> <p><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</p> <p><img src="/assets/img/watch-observer.5de7af21.png" alt="Image"></p> <h3 id="如何进行数组变化侦测"><a href="#如何进行数组变化侦测" class="header-anchor">#</a> 如何进行数组变化侦测</h3> <p>现在又发现了新的问题，<code>data</code> 中不是所有的 <code>value</code> 都是对象和基本类型，如果是一个数组怎么办？数组是没有办法通过 <code>Object.defineProperty</code> 来侦测到行为的。</p> <p>vue 中对这个数组问题的解决方案非常的简单粗暴，vue是如何实现的，大体上分三步：</p> <p>第一步：先把原生 <code>Array</code> 的原型方法继承下来。</p> <p>第二步：对继承后的对象使用 <code>Object.defineProperty</code> 做一些拦截操作。</p> <p>第三步：把加工后可以被拦截的原型，赋值到需要被拦截的 <code>Array</code> 类型的数据的原型上。</p> <p>。。。有待继续补充关于数组的变化侦测实现原理部分</p> <h2 id="vue中的生命周期"><a href="#vue中的生命周期" class="header-anchor">#</a> Vue中的生命周期</h2> <img src="/assets/img/lifecycle1.83ab546d.png" alt="Image" style="zoom:50%;"> <img src="/assets/img/lifecycle2.a31e3278.png" style="zoom:60%;"></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">11/27/2020, 10:46:38 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/foundation/js.html" class="prev">
        Javascript
      </a></span> <span class="next"><a href="/foundation/css.html">
        CSS
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.81356f24.js" defer></script><script src="/assets/js/2.2bdd9eae.js" defer></script><script src="/assets/js/3.4918c403.js" defer></script>
  </body>
</html>
